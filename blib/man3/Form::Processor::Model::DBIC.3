.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Form::Processor::Model::DBIC 3"
.TH Form::Processor::Model::DBIC 3 "2009-09-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Form::Processor::Model::DBIC \- Model class for Form Processor using DBIx::Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
You need to create a form class, templates, and call F::P from a controller.
.PP
Create a Form, subclassed from Form::Processor::Model::DBIC
.PP
.Vb 3
\&    package MyApp:Form::User;
\&    use strict;
\&    use base \*(AqForm::Processor::Model::DBIC\*(Aq;
\&
\&    # Associate this form with a DBIx::Class result class
\&    sub object_class { \*(AqUser\*(Aq } # Where \*(AqUser\*(Aq is the DBIC source_name 
\&
\&    # Define the fields that this form will operate on
\&    # Field names must be column or relationship names in your
\&    # DBIx::Class result class
\&    sub profile {
\&        return {
\&            fields => {
\&                name        => {
\&                   type => \*(AqText\*(Aq,
\&                   label => \*(AqName:\*(Aq,
\&                   required => 1,
\&                   noupdate => 1,
\&                },
\&                age         => {
\&                    type => \*(AqPosInteger\*(Aq,
\&                    label    => \*(AqAge:\*(Aq,
\&                    required => 1,
\&                },
\&                sex         => {
\&                    type => \*(AqSelect\*(Aq,
\&                    label => \*(AqGender:\*(Aq,
\&                    required => 1,
\&                },
\&                birthdate   => \*(Aq+MyApp::Field::Date\*(Aq, # customized field class
\&                hobbies     =>  {
\&                    type => \*(AqMultiple\*(Aq,
\&                    size => 5,
\&                },
\&                address     => \*(AqText\*(Aq,
\&                city        => \*(AqText\*(Aq,
\&                state       => \*(AqSelect\*(Aq,
\&            },
\&
\&            dependency => [
\&                [\*(Aqaddress\*(Aq, \*(Aqcity\*(Aq, \*(Aqstate\*(Aq],
\&            ],
\&        };
.Ve
.PP
Then in your template:
.PP
For an input field:
.PP
.Vb 5
\&   <p>
\&   [% f = form.field(\*(Aqaddress\*(Aq) %]
\&   <label class="label" for="[% f.name %]">[% f.label || f.name %]</label>
\&   <input type="text" name="[% f.name %]" id="[% f.name %]">
\&   </p>
.Ve
.PP
For a select list provide a relationship name as the field name, or provide
an options_<field_name> subroutine in the form. (field attributes: sort_order, 
label_column, active_column). \s-1TT\s0 example:
.PP
.Vb 9
\&   <p>
\&   [% f = form.field(\*(Aqsex\*(Aq) %]
\&   <label class="label" for="[% f.name %]">[% f.label || f.name %]</label>
\&   <select name="[% f.name %]">
\&     [% FOR option IN f.options %]
\&       <option value="[% option.value %]" [% IF option.value == f.value %]selected="selected"[% END %]>[% option.label | html %]</option>
\&     [% END %] 
\&   </select>
\&   </p>
.Ve
.PP
A multiple select list where 'hobbies' is the 'has_many' relationship for
a 'many_to_many' pseudo-relationship. (field attributes: sort_order, label_column,
active_column).
.PP
.Vb 9
\&   <p>
\&   [% f = form.field(\*(Aqhobbies\*(Aq) %]
\&   <label class="label" for="[% f.name %]">[% f.label || f.name %]</label>
\&   <select name="[% f.name %]" multiple="multiple" size="[% f.size %]">
\&     [% FOR option IN f.options %]
\&       <option value="[% option.value %]" [% FOREACH selval IN f.value %][% IF selval == option.value %]selected="selected"[% END %][% END %]>[% option.label | html %]</option>
\&     [% END %] 
\&   </select>
\&   </p>
.Ve
.PP
For a complex, widget-based \s-1TT\s0 setup, see the examples directory in the
Catalyst::Plugin::Form::Processor \s-1CPAN\s0 download.
.PP
Then in a Catalyst controller (with Catalyst::Controller::Form::Processor):
.PP
.Vb 4
\&    package MyApp::Controller::User;
\&    use strict;
\&    use warnings;
\&    use base \*(AqCatalyst::Controller::Form::Processor\*(Aq;
\&
\&    # Create or edit
\&    sub edit : Local {
\&        my ( $self, $c, $user_id ) = @_;
\&        $c\->stash\->{template} = \*(Aquser/edit.tt\*(Aq; 
\&        # Validate and insert/update database. Args = pk, form name
\&        return unless $self\->update_from_form( $user_id, \*(AqUser\*(Aq );
\&        # Form validated.
\&        $c\->stash\->{user} = $c\->stash\->{form}\->item;
\&        $c\->res\->redirect($c\->uri_for(\*(Aqprofile\*(Aq));
\&    }
.Ve
.PP
With the Catalyst controller the schema is set from the model_name config
options, ($c\->model($model_name)...), but it can also be set by passing 
in the schema on \*(L"new\*(R", or setting with \f(CW$form\fR\->schema($schema). You can
also set a config values for whether or not to use FillInForm, and
the form namespace.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This \s-1DBIC\s0 model will save form fields automatically to the database, will
retrieve selection lists from the database (with type => 'Select' and a 
fieldname containing a single relationship, or type => 'Multiple' and a
has_many relationship), and will save the selected values (one value for 
\&'Select', multiple values in a mapping table for a 'Multiple' field).
.PP
This package includes a working example using a SQLite database and a
number of forms. The templates are straightforward and unoptimized to
make it easier to see what they're doing.
.SH "METHODS"
.IX Header "METHODS"
.Sh "schema"
.IX Subsection "schema"
The schema method is primarily intended for non-Catalyst users, so
that they can pass in their DBIx::Class schema object.
.Sh "update_from_form"
.IX Subsection "update_from_form"
.Vb 1
\&    my $validated = $form\->update_from_form( $parameter_hash );
.Ve
.PP
This is not the same as the routine called with \f(CW$self\fR\->update_from_form. That
is a Catalyst plugin routine that calls this one. This routine updates or
creates the object from values in the form.
.PP
All fields that refer to columns and have changed will be updated. Field names
that are a single relationship will be updated. Any field names that are related 
to the class by \*(L"has_many\*(R" are assumed to have a mapping table and will be 
updated.  Validation is run unless validation has already been run.  
($form\->clear might need to be called if the \f(CW$form\fR object stays in memory
between requests.)
.PP
The actual update is done in the \f(CW\*(C`update_model\*(C'\fR method.  Your form class can
override that method (but don't forget to call \s-1SUPER\s0) if you wish to do additional
database inserts or updates.  This is useful when a single form updates 
multiple tables, or there are secondary tables to update.
.PP
Returns false if form does not validate, otherwise returns 1.  Very likely dies on database errors.
.Sh "model_validate"
.IX Subsection "model_validate"
The place to put validation that requires database-specific lookups.
Subclass this method in your form.
.Sh "update_model"
.IX Subsection "update_model"
This is where the database row is updated. If you want to do some extra
database processing (such as updating a related table) this is the
method to subclass in your form.
.PP
It currently assumes that any \*(L"has_many\*(R" relationship name used as a
field in your form is for a \*(L"multiple\*(R" select list. This will probably
change in the future.
.PP
This routine allows the use of non-database (non-column, non-relationship) 
accessors in your result source class. It identifies form fields as 1) column,
2) relationship, 3) other. Column and other fields are processed and update
is called on the row. Then relationships are processed.
.PP
If the row doesn't exist (no primary key or row object was passed in), then
a row is created using \*(L"create\*(R" and the fields identified as columns passed
in a hashref, followed by \*(L"other\*(R" fields and relationships.
.Sh "guess_field_type"
.IX Subsection "guess_field_type"
This subroutine is only called for \*(L"auto\*(R" fields, defined like:
    return {
       auto_required => ['name', 'age', 'sex', 'birthdate'],
       auto_optional => ['hobbies', 'address', 'city', 'state'],
    };
.PP
Pass in a column and it will guess the field type and return it.
.PP
Currently returns:
    DateTimeDMYHM   \- for a has_a relationship that isa DateTime
    Select          \- for a has_a relationship
    Multiple        \- for a has_many
.PP
otherwise:
    DateTimeDMYHM   \- if the field ends in _time
    Text            \- otherwise
.PP
Subclass this method to do your own field type assignment based
on column types. This routine returns either an array or type string.
.Sh "lookup_options"
.IX Subsection "lookup_options"
This method is used with \*(L"Single\*(R" and \*(L"Multiple\*(R" field select lists 
(\*(L"single\*(R", \*(L"filter\*(R", and \*(L"multi\*(R" relationships).
It returns an array reference of key/value pairs for the column passed in.
The column name defined in \f(CW$field\fR\->label_column will be used as the label.
The default label_column is \*(L"name\*(R".  The labels are sorted by Perl's cmp sort.
.PP
If there is an \*(L"active\*(R" column then only active values are included, except 
if the form (item) has currently selected the inactive item.  This allows
existing records that reference inactive items to still have those as valid select
options.  The inactive labels are formatted with brackets to indicate in the select
list that they are inactive.
.PP
The active column name is determined by calling:
    \f(CW$active_col\fR = \f(CW$form\fR\->can( 'active_column' )
        ? \f(CW$form\fR\->active_column
        : \f(CW$field\fR\->active_column;
.PP
This allows setting the name of the active column globally if
your tables are consistantly named (all lookup tables have the same
column name to indicate they are active), or on a per-field basis.
.PP
The column to use for sorting the list is specified with \*(L"sort_order\*(R". 
The currently selected values in a Multiple list are grouped at the top
(by the Multiple field class).
.Sh "init_value"
.IX Subsection "init_value"
This method returns a field's value (for \f(CW$field\fR\->value) with
either a scalar or an array ref from the object stored in \f(CW$form\fR\->item.
.PP
This method is not called if a method \*(L"init_value_$field_name\*(R" is found 
in the form class \- that method is called instead.
This allows overriding specific fields in your form class.
.Sh "validate_unique"
.IX Subsection "validate_unique"
For fields that are marked \*(L"unique\*(R", checks the database for uniqueness.
.PP
.Vb 2
\&   arraryref:
\&        unique => [\*(Aquser_id\*(Aq, \*(Aqusername\*(Aq]
\&
\&   or hashref:
\&        unique => {
\&            username => \*(AqThat username is already taken\*(Aq,
\&        }
.Ve
.Sh "init_item"
.IX Subsection "init_item"
This is called first time \f(CW$form\fR\->item is called.
If using the Catalyst plugin, it sets the DBIx::Class schema from
the Catalyst context, and the model specified as the first part
of the object_class in the form. If not using Catalyst, it uses
the \*(L"schema\*(R" passed in on \*(L"new\*(R".
.PP
It then does:
.PP
.Vb 1
\&    return $self\->resultset\->find( $self\->item_id );
.Ve
.PP
It also validates that the item id matches /^\ed+$/.  Override this method
in your form class (or form base class) if your ids do not match that pattern.
.PP
If a database row for the item_id is not found, item_id will be set to undef.
.Sh "init_schema"
.IX Subsection "init_schema"
Initializes the DBIx::Class schema. User may override. Non-Catalyst
users should pass schema in on new:  
\&\f(CW$my_form_class\fR\->new(item_id => \f(CW$id\fR, schema => \f(CW$schema\fR)
.Sh "source"
.IX Subsection "source"
Returns a DBIx::Class::ResultSource object for this Result Class.
.Sh "resultset"
.IX Subsection "resultset"
This method returns a resultset from the \*(L"object_class\*(R" specified
in the form, or from the foreign class that is retrieved from
a relationship.
.Sh "many_to_many"
.IX Subsection "many_to_many"
When passed the name of the has_many relationship for a many_to_many
pseudo-relationship, this subroutine returns the relationship and column
name from the mapping table to the current table, and the relationship and
column name from the mapping table to the foreign table.
.PP
This code assumes that the mapping table has only two columns 
and two relationships, and you must have correct DBIx::Class relationships
defined.
.PP
For different table arrangements you could subclass 
this method to return the correct relationship and column names.
.Sh "build_form and _build_fields"
.IX Subsection "build_form and _build_fields"
These methods from Form::Processor are subclassed here to allow 
combining \*(L"required\*(R" and \*(L"optional\*(R" lists in one \*(L"fields\*(R" list, 
with \*(L"required\*(R" set like other field attributes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Form::Processor
Form::Processor::Field
Form::Processor::Model::CDBI
Catalyst::Controller:Form::Processor
Rose::Object
.SH "AUTHOR"
.IX Header "AUTHOR"
Gerda Shank, gshank@cpan.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Based on Form::Processor::Model::CDBI written by Bill Moseley.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software, you can redistribute it and/or modify it under
the same terms as Perl itself.
